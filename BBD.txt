const fs = require("fs");
const path = require("path");

const featureFiles = [];

// Function to recursively find all .feature files
const findFeatureFiles = (dir) => {
  const files = fs.readdirSync(dir);
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat.isDirectory()) {
      findFeatureFiles(filePath); // Recursion for subdirectories
    } else if (file.endsWith(".feature")) {
      featureFiles.push(filePath);
    }
  }
};

// Function to parse a .feature file and extract relevant data
const parseFeatureFile = (filePath) => {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");
  const scenarios = [];
  const metadata = {};
  let tags = []; // Array to hold tags
  let inFeatureSection = false; // Flag to start processing after the Feature line

  lines.forEach((line) => {
    line = line.trim();

    // Start processing after the "Feature:" line
    if (line.startsWith("Feature:")) {
      inFeatureSection = true;
      return; // Skip processing the "Feature:" line itself
    }

    if (!inFeatureSection) {
      // Skip lines before "Feature:"
      return;
    }

    if (line.startsWith("#")) {
      const [key, ...valueParts] = line.split(":").map((part) => part.trim());
      if (key && valueParts.length > 0) {
        const value = valueParts.join(":").trim(); // Handle cases with ':' in value
        metadata[key] = value; // Store full URL or value
      }
    } else if (line.startsWith("@")) {
      // Collect tags
      tags.push(line.trim());
    } else if (line.startsWith("Scenario Outline:")) {
      const scenario = line.replace("Scenario Outline:", "").trim();
      scenarios.push({
        scenario,
        metadata: { ...metadata },
        tags: tags.join(" "),
      });
      tags = []; // Reset tags for the next scenario
    }
  });

  return scenarios;
};

// Collect all feature files
findFeatureFiles(__dirname);

// Prepare data for CSV
const records = [];
let totalScenarios = {
  Chrome: 0,
  Firefox: 0,
  AndroidChromeBrowser: 0,
  iPhoneSafariBrowser: 0,
}; // Total scenarios that are not N/A
let executedScenarios = {
  Chrome: 0,
  Firefox: 0,
  AndroidChromeBrowser: 0,
  iPhoneSafariBrowser: 0,
};

// Iterate through each feature file and extract data
featureFiles.forEach((filePath, index) => {
  const scenarios = parseFeatureFile(filePath);
  scenarios.forEach(({ scenario, metadata, tags }) => {
    const chromeValue = metadata["#Chrome"] || "";
    const firefoxValue = metadata["#Firefox"] || "";
    const androidChromeValue = metadata["#AndroidChromeBrowser"] || "";
    const iPhoneSafariValue = metadata["#iPhoneSafariBrowser"] || "";

    const record = {
      NUM: index + 1,
      "File Name": path.basename(filePath),
      Scenario: scenario,
      Author: metadata["#Author"] || "",
      Tags: tags || "",
      Jira: metadata["#Jira"] || "",
      Chrome: chromeValue === "N/A" ? "N/A" : chromeValue,
      Firefox: firefoxValue === "N/A" ? "N/A" : firefoxValue,
      AndroidChromeBrowser:
        androidChromeValue === "N/A" ? "N/A" : androidChromeValue,
      iPhoneSafariBrowser:
        iPhoneSafariValue === "N/A" ? "N/A" : iPhoneSafariValue,
    };
    records.push(record);

    Object.keys(totalScenarios).forEach((browser) => {
      if (record[browser] !== "N/A") {
        totalScenarios[browser]++;
      }
    });

    // Count executed scenarios
    Object.keys(executedScenarios).forEach((browser) => {
      if (record[browser] !== "N/A" && record[browser] !== "") {
        executedScenarios[browser]++;
      }
    });
  });
});

// Add summary rows
const totalRecord = {
  NUM: "",
  "File Name": "",
  Scenario: "",
  Author: "",
  Tags: "",
  Jira: "Total Scenarios",
  Chrome: totalScenarios.Chrome,
  Firefox: totalScenarios.Firefox,
  AndroidChromeBrowser: totalScenarios.AndroidChromeBrowser,
  iPhoneSafariBrowser: totalScenarios.iPhoneSafariBrowser,
};

const executedRecord = {
  NUM: "",
  "File Name": "",
  Scenario: "",
  Author: "",
  Tags: "",
  Jira: "Scenarios Executed",
  Chrome: executedScenarios.Chrome,
  Firefox: executedScenarios.Firefox,
  AndroidChromeBrowser: executedScenarios.AndroidChromeBrowser,
  iPhoneSafariBrowser: executedScenarios.iPhoneSafariBrowser,
};

const percentageRecord = {
  NUM: "",
  "File Name": "",
  Scenario: "",
  Author: "",
  Tags: "",
  Jira: "Percentage",
  Chrome:
    totalScenarios.Chrome === 0
      ? "0%"
      : `${((executedScenarios.Chrome / totalScenarios.Chrome) * 100).toFixed(
          2
        )}%`,
  Firefox:
    totalScenarios.Firefox === 0
      ? "0%"
      : `${((executedScenarios.Firefox / totalScenarios.Firefox) * 100).toFixed(
          2
        )}%`,
  AndroidChromeBrowser:
    totalScenarios.AndroidChromeBrowser === 0
      ? "0%"
      : `${(
          (executedScenarios.AndroidChromeBrowser /
            totalScenarios.AndroidChromeBrowser) *
          100
        ).toFixed(2)}%`,
  iPhoneSafariBrowser:
    totalScenarios.iPhoneSafariBrowser === 0
      ? "0%"
      : `${(
          (executedScenarios.iPhoneSafariBrowser /
            totalScenarios.iPhoneSafariBrowser) *
          100
        ).toFixed(2)}%`,
};

records.push(totalRecord, executedRecord, percentageRecord);

// Function to convert records to CSV format
const generateCSV = (records) => {
  const header = [
    "#NUM",
    "File Name",
    "Scenario",
    "Author",
    "Tags",
    "Jira",
    "Chrome",
    "Firefox",
    "AndroidChromeBrowser",
    "iPhoneSafariBrowser",
  ];

  const csvRows = [header.join(",")]; // Add header

  records.forEach((record) => {
    const row = [
      record.NUM,
      record["File Name"],
      record.Scenario,
      record.Author,
      record.Tags,
      record.Jira,
      record.Chrome,
      record.Firefox,
      record.AndroidChromeBrowser,
      record.iPhoneSafariBrowser,
    ];
    csvRows.push(row.join(",")); // Convert record to CSV row
  });

  return csvRows.join("\n"); // Join all rows with a newline
};

// Write the CSV content to a file
const csvContent = generateCSV(records);
fs.writeFileSync("feature_report.csv", csvContent, "utf-8");

console.log("CSV file has been written successfully.");
